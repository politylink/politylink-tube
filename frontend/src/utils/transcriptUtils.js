/***
 WARNING: these methods rely heavily on the DOM structure generated by <Transcript> component.
 This is obviously not the best approach, but not yet sure about alternatives.
 ***/


export const findActiveWordPosition = (transcriptRoot, time) => {
    const utteranceNodes = transcriptRoot.childNodes[0].childNodes;
    for (const [uid, utterance] of utteranceNodes.entries()) {
        const wordNodes = utterance.childNodes[1].childNodes;
        for (const [wid, word] of wordNodes.entries()) {
            if (word.getAttribute('data-end') > time) {
                return [uid, wid];
            }
        }
    }
    return null;
}

export const eqWordPosition = (p1, p2) => {
    if (p1 === null || p2 === null) {
        return false;
    }
    return p1[0] === p2[0] && p1[1] === p2[1];
}

export const getWordNode = (transcriptRoot, wordPosition) => {
    const utteranceNodes = transcriptRoot.childNodes[0].childNodes;
    const [uid, wid] = wordPosition;
    return utteranceNodes[uid].childNodes[1].childNodes[wid];
}

export const editWordNodeClass = (transcriptRoot, wordPosition, className, add = true) => {
    if (wordPosition === null) {
        return;
    }
    const node = getWordNode(transcriptRoot, wordPosition);
    if (add) {
        node.classList.add(className);
    } else {
        node.classList.remove(className);
    }
}

export const scrollToWord = (transcriptRoot, wordPosition) => {
    if (wordPosition === null) {
        return;
    }
    const word = getWordNode(transcriptRoot, wordPosition);
    transcriptRoot.scrollTo({top: word.offsetTop - 100, behavior: "auto"});
}